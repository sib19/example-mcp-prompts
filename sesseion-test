# “””
FastMCP User Session Management for Tool Calling

This guide demonstrates how to implement user session management
in FastMCP servers to handle multi-user scenarios and stateful interactions.
“””

from fastmcp import FastMCP
from typing import Dict, Any, Optional
from datetime import datetime
import asyncio

# Initialize FastMCP server

mcp = FastMCP(“Session Management Example”)

# ============================================

# 1. BASIC SESSION STORAGE

# ============================================

class SessionManager:
“”“Manages user sessions with isolated state”””

```
def __init__(self):
    self.sessions: Dict[str, Dict[str, Any]] = {}

def get_session(self, session_id: str) -> Dict[str, Any]:
    """Get or create a session"""
    if session_id not in self.sessions:
        self.sessions[session_id] = {
            "created_at": datetime.now(),
            "data": {},
            "call_count": 0
        }
    return self.sessions[session_id]

def update_session(self, session_id: str, key: str, value: Any):
    """Update session data"""
    session = self.get_session(session_id)
    session["data"][key] = value

def get_session_data(self, session_id: str, key: str, default=None):
    """Retrieve session data"""
    session = self.get_session(session_id)
    return session["data"].get(key, default)

def clear_session(self, session_id: str):
    """Clear a specific session"""
    if session_id in self.sessions:
        del self.sessions[session_id]
```

# Global session manager

session_mgr = SessionManager()

# ============================================

# 2. SESSION-AWARE TOOLS

# ============================================

@mcp.tool()
def set_user_preference(session_id: str, preference_key: str, preference_value: str) -> str:
“””
Store a user preference for this session

```
Args:
    session_id: Unique identifier for the user session
    preference_key: Name of the preference (e.g., 'language', 'theme')
    preference_value: Value to store
"""
session_mgr.update_session(session_id, preference_key, preference_value)
return f"Preference '{preference_key}' set to '{preference_value}' for session {session_id}"
```

@mcp.tool()
def get_user_preference(session_id: str, preference_key: str) -> str:
“””
Retrieve a user preference from this session

```
Args:
    session_id: Unique identifier for the user session
    preference_key: Name of the preference to retrieve
"""
value = session_mgr.get_session_data(session_id, preference_key)
if value is None:
    return f"No preference found for '{preference_key}'"
return f"Preference '{preference_key}' is set to '{value}'"
```

@mcp.tool()
def track_tool_usage(session_id: str, tool_name: str) -> str:
“””
Track tool usage per session for analytics

```
Args:
    session_id: Unique identifier for the user session
    tool_name: Name of the tool being used
"""
session = session_mgr.get_session(session_id)
session["call_count"] += 1

# Track per-tool usage
usage_key = f"tool_usage_{tool_name}"
current = session_mgr.get_session_data(session_id, usage_key, 0)
session_mgr.update_session(session_id, usage_key, current + 1)

return f"Tool '{tool_name}' called. Total session calls: {session['call_count']}"
```

# ============================================

# 3. CONTEXT-AWARE SESSION MANAGEMENT

# ============================================

@mcp.tool()
def add_to_shopping_cart(session_id: str, item: str, quantity: int = 1) -> str:
“””
Add items to a user’s shopping cart (session-specific)

```
Args:
    session_id: Unique identifier for the user session
    item: Item name
    quantity: Number of items to add
"""
cart = session_mgr.get_session_data(session_id, "cart", [])
cart.append({"item": item, "quantity": quantity, "added_at": datetime.now().isoformat()})
session_mgr.update_session(session_id, "cart", cart)

return f"Added {quantity}x {item} to cart. Total items: {len(cart)}"
```

@mcp.tool()
def view_shopping_cart(session_id: str) -> str:
“””
View the current shopping cart for this session

```
Args:
    session_id: Unique identifier for the user session
"""
cart = session_mgr.get_session_data(session_id, "cart", [])

if not cart:
    return "Shopping cart is empty"

result = "Shopping Cart:\n"
for idx, item in enumerate(cart, 1):
    result += f"{idx}. {item['quantity']}x {item['item']}\n"

return result
```

@mcp.tool()
def clear_shopping_cart(session_id: str) -> str:
“””
Clear the shopping cart for this session

```
Args:
    session_id: Unique identifier for the user session
"""
session_mgr.update_session(session_id, "cart", [])
return "Shopping cart cleared"
```

# ============================================

# 4. CONVERSATION STATE MANAGEMENT

# ============================================

@mcp.tool()
def remember_context(session_id: str, context_key: str, context_value: str) -> str:
“””
Store conversation context for later reference

```
Args:
    session_id: Unique identifier for the user session
    context_key: Key for the context (e.g., 'user_goal', 'last_topic')
    context_value: Context information to remember
"""
context = session_mgr.get_session_data(session_id, "context", {})
context[context_key] = {
    "value": context_value,
    "timestamp": datetime.now().isoformat()
}
session_mgr.update_session(session_id, "context", context)

return f"Remembered: {context_key} = {context_value}"
```

@mcp.tool()
def recall_context(session_id: str, context_key: str) -> str:
“””
Recall previously stored conversation context

```
Args:
    session_id: Unique identifier for the user session
    context_key: Key for the context to recall
"""
context = session_mgr.get_session_data(session_id, "context", {})

if context_key not in context:
    return f"No context found for '{context_key}'"

ctx_data = context[context_key]
return f"Recalled: {context_key} = {ctx_data['value']} (from {ctx_data['timestamp']})"
```

# ============================================

# 5. SESSION LIFECYCLE MANAGEMENT

# ============================================

@mcp.tool()
def get_session_info(session_id: str) -> str:
“””
Get information about the current session

```
Args:
    session_id: Unique identifier for the user session
"""
session = session_mgr.get_session(session_id)

info = f"""
```

Session ID: {session_id}
Created: {session[‘created_at’].isoformat()}
Total Tool Calls: {session[‘call_count’]}
Stored Data Keys: {list(session[‘data’].keys())}
“””
return info.strip()

@mcp.tool()
def reset_session(session_id: str) -> str:
“””
Reset/clear all data for this session

```
Args:
    session_id: Unique identifier for the user session
"""
session_mgr.clear_session(session_id)
return f"Session {session_id} has been reset"
```

# ============================================

# 6. BEST PRACTICES & PATTERNS

# ============================================

“””
KEY BEST PRACTICES:

1. **Session ID Generation**
- Generate unique session IDs (UUID, timestamp-based)
- Pass session_id as first parameter to all tools
- Client manages session ID across requests
1. **Data Isolation**
- Each session maintains separate state
- No cross-session data leakage
- Clear session boundaries
1. **State Persistence**
- In-memory (simple, non-persistent)
- Redis (distributed, persistent)
- Database (long-term, queryable)
1. **Session Timeout**
- Implement TTL for inactive sessions
- Clean up expired sessions periodically
- Notify users of session expiry
1. **Security Considerations**
- Validate session IDs
- Implement session authentication
- Encrypt sensitive session data
- Rate limiting per session
1. **Error Handling**
- Graceful handling of missing sessions
- Clear error messages
- Session recovery mechanisms

INTEGRATION PATTERNS:

# Client-side (pseudo-code)

session_id = generate_uuid()

# All tool calls include session_id

mcp.call_tool(“set_user_preference”, {
“session_id”: session_id,
“preference_key”: “theme”,
“preference_value”: “dark”
})

# Persist session_id in client storage

localStorage.setItem(“mcp_session_id”, session_id)
“””

# ============================================

# 7. ADVANCED: REDIS-BASED SESSIONS

# ============================================

“””
For production systems with multiple server instances:

import redis
import json

class RedisSessionManager:
def **init**(self, redis_url: str):
self.redis = redis.from_url(redis_url)
self.ttl = 3600  # 1 hour

```
def get_session(self, session_id: str) -> Dict[str, Any]:
    data = self.redis.get(f"session:{session_id}")
    if data is None:
        return {"data": {}, "created_at": datetime.now().isoformat()}
    return json.loads(data)

def update_session(self, session_id: str, key: str, value: Any):
    session = self.get_session(session_id)
    session["data"][key] = value
    self.redis.setex(
        f"session:{session_id}",
        self.ttl,
        json.dumps(session)
    )

def clear_session(self, session_id: str):
    self.redis.delete(f"session:{session_id}")
```

# Usage:

# session_mgr = RedisSessionManager(“redis://localhost:6379”)

“””

if **name** == “**main**”:
# Run the MCP server
mcp.run()