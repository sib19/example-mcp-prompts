import functools
import time
from typing import Optional, Callable, Any

# Global token storage

_auth_token: Optional[str] = None
_token_expiry: float = 0

# ============================================================================

# CORE TOKEN MANAGEMENT

# ============================================================================

def get_login_token() -> str:
â€œâ€â€œSimulates getting a login token from authentication service.â€â€â€
print(â€œğŸ” Fetching new login tokenâ€¦â€)
time.sleep(0.5)  # Simulate API call
token = fâ€token_{int(time.time())}â€
print(fâ€âœ“ Token obtained: {token}â€)
return token

def refresh_token_if_needed() -> str:
â€œâ€â€œChecks if token exists and is valid, refreshes if needed.â€â€â€
global _auth_token, _token_expiry
current_time = time.time()

```
if _auth_token is None or current_time >= _token_expiry:
    _auth_token = get_login_token()
    _token_expiry = current_time + 3600
else:
    print(f"âœ“ Using cached token: {_auth_token}")

return _auth_token
```

# ============================================================================

# DECORATOR PATTERN EXAMPLES

# ============================================================================

# Example 1: Basic Decorator - Token as First Argument

def requires_auth(func: Callable) -> Callable:
â€œâ€â€œBasic decorator that passes token as first argument.â€â€â€
@functools.wraps(func)
def wrapper(*args, **kwargs):
token = refresh_token_if_needed()
return func(token, *args, **kwargs)
return wrapper

# Example 2: Decorator with Token as Keyword Argument

def requires_auth_kwarg(func: Callable) -> Callable:
â€œâ€â€œDecorator that passes token as â€˜tokenâ€™ keyword argument.â€â€â€
@functools.wraps(func)
def wrapper(*args, **kwargs):
token = refresh_token_if_needed()
kwargs[â€˜tokenâ€™] = token
return func(*args, **kwargs)
return wrapper

# Example 3: Decorator with Headers Dictionary

def requires_auth_headers(func: Callable) -> Callable:
â€œâ€â€œDecorator that creates headers dict with Authorization.â€â€â€
@functools.wraps(func)
def wrapper(*args, **kwargs):
token = refresh_token_if_needed()
headers = {â€œAuthorizationâ€: fâ€Bearer {token}â€}
return func(headers, *args, **kwargs)
return wrapper

# Example 4: Decorator with Retry Logic

def requires_auth_with_retry(max_retries: int = 3):
â€œâ€â€œDecorator that retries on authentication failure.â€â€â€
def decorator(func: Callable) -> Callable:
@functools.wraps(func)
def wrapper(*args, **kwargs):
for attempt in range(max_retries):
try:
token = refresh_token_if_needed()
return func(token, *args, **kwargs)
except AuthenticationError as e:
print(fâ€âš ï¸  Auth failed (attempt {attempt + 1}/{max_retries}): {e}â€)
global _auth_token, _token_expiry
_auth_token = None  # Force token refresh
if attempt == max_retries - 1:
raise
return None
return wrapper
return decorator

# Example 5: Class-based Decorator

class RequiresAuth:
â€œâ€â€œClass-based decorator for authentication.â€â€â€
def **init**(self, func: Callable):
self.func = func
functools.update_wrapper(self, func)

```
def __call__(self, *args, **kwargs):
    token = refresh_token_if_needed()
    return self.func(token, *args, **kwargs)
```

# Example 6: Decorator with Custom Token Parameter Name

def requires_auth_custom_param(param_name: str = â€œauth_tokenâ€):
â€œâ€â€œDecorator that allows custom parameter name for token.â€â€â€
def decorator(func: Callable) -> Callable:
@functools.wraps(func)
def wrapper(*args, **kwargs):
token = refresh_token_if_needed()
kwargs[param_name] = token
return func(*args, **kwargs)
return wrapper
return decorator

# Custom exception for example 4

class AuthenticationError(Exception):
pass

# ============================================================================

# USAGE EXAMPLES

# ============================================================================

# Using Example 1: Token as first argument

@requires_auth
def get_user_profile(token: str, user_id: int) -> dict:
print(fâ€\nğŸ“Š [Ex1] Getting profile for user {user_id}â€)
print(fâ€   Token: {token}â€)
return {â€œuser_idâ€: user_id, â€œnameâ€: â€œAliceâ€}

# Using Example 2: Token as keyword argument

@requires_auth_kwarg
def update_settings(user_id: int, settings: dict, token: str = None) -> dict:
print(fâ€\nâš™ï¸  [Ex2] Updating settings for user {user_id}â€)
print(fâ€   Token: {token}â€)
print(fâ€   Settings: {settings}â€)
return {â€œsuccessâ€: True}

# Using Example 3: Headers dictionary

@requires_auth_headers
def make_api_request(headers: dict, endpoint: str, data: dict) -> dict:
print(fâ€\nğŸŒ [Ex3] Making API request to {endpoint}â€)
print(fâ€   Headers: {headers}â€)
print(fâ€   Data: {data}â€)
return {â€œstatusâ€: â€œokâ€}

# Using Example 4: With retry logic

@requires_auth_with_retry(max_retries=2)
def delete_resource(token: str, resource_id: int) -> dict:
print(fâ€\nğŸ—‘ï¸  [Ex4] Deleting resource {resource_id}â€)
print(fâ€   Token: {token}â€)
# Simulate occasional auth failures
# if resource_id == 999:
#     raise AuthenticationError(â€œInvalid tokenâ€)
return {â€œdeletedâ€: True}

# Using Example 5: Class-based decorator

@RequiresAuth
def fetch_data(token: str, query: str) -> list:
print(fâ€\nğŸ” [Ex5] Fetching data with query: {query}â€)
print(fâ€   Token: {token}â€)
return [{â€œidâ€: 1, â€œdataâ€: â€œsampleâ€}]

# Using Example 6: Custom parameter name

@requires_auth_custom_param(param_name=â€œapi_keyâ€)
def send_notification(user_id: int, message: str, api_key: str = None) -> dict:
print(fâ€\nğŸ“§ [Ex6] Sending notification to user {user_id}â€)
print(fâ€   API Key: {api_key}â€)
print(fâ€   Message: {message}â€)
return {â€œsentâ€: True}

# Combining multiple decorators

def log_execution(func: Callable) -> Callable:
â€œâ€â€œAdditional decorator for logging.â€â€â€
@functools.wraps(func)
def wrapper(*args, **kwargs):
print(fâ€\nâ–¶ï¸  Starting {func.**name**}â€¦â€)
result = func(*args, **kwargs)
print(fâ€âœ… Finished {func.**name**}â€)
return result
return wrapper

@log_execution
@requires_auth
def complex_operation(token: str, operation: str) -> dict:
print(fâ€\nğŸ”§ [Ex7] Performing {operation}â€)
print(fâ€   Token: {token}â€)
return {â€œoperationâ€: operation, â€œstatusâ€: â€œcompletedâ€}

# ============================================================================

# DEMO

# ============================================================================

if **name** == â€œ**main**â€:
print(â€=â€ * 60)
print(â€œDECORATOR PATTERN EXAMPLESâ€)
print(â€=â€ * 60)

```
# Example 1
get_user_profile(user_id=123)

# Example 2
update_settings(user_id=123, settings={"theme": "dark"})

# Example 3
make_api_request(endpoint="/api/v1/data", data={"key": "value"})

# Example 4
delete_resource(resource_id=456)

# Example 5
fetch_data(query="SELECT * FROM users")

# Example 6
send_notification(user_id=789, message="Hello!")

# Example 7 - Multiple decorators
complex_operation(operation="data_migration")

print("\n" + "=" * 60)
print("TOKEN CACHING DEMONSTRATION")
print("=" * 60)

# These will reuse the cached token
get_user_profile(user_id=111)
update_settings(user_id=222, settings={"language": "en"})

print("\n" + "=" * 60)
print("All examples completed!")
print("=" * 60)
```